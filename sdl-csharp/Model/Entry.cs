using sdl_csharp.Utility;
using sdl_csharp.ViewModel;
using System;
using System.Diagnostics;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using YoutubeExplode;
using YoutubeExplode.Common;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Videos;

namespace sdl_csharp.Model.Entry
{
    public enum EntryStatus
    {
        INITIALIZED,
        DOWNLOADING,
        CONVERTING,
        DONE,
        CANCELLED,
        ERROR
    }
    public enum EntryType
    {
        SINGLE,
        MEMBER,
        PLAYLIST
    }

    public class Entry : NotifyPropertyChanged
    {
        CancellationTokenSource cancelTaskSource;
        Task task;
        public EntryType type;
        public dynamic data;
        public string url;
        public string videoId;
        public string playlistId;
        public DateTime downloadStart;

        // this is updated from inside the class
        private EntryStatus status;
        public EntryStatus Status { get => status; set => Set(ref status, value); }

        public Entry(string _url)
        {
            Logger.Log($"Entry {_url}");

            url = _url;
            type = EntryParser.GetType(url, ref videoId, ref playlistId) ?? type;
            data = type switch
            {
                EntryType.SINGLE => new EntrySingleData(),
                EntryType.MEMBER => new EntryMemberData(),
                EntryType.PLAYLIST => new EntryPlaylistData(),
                _ => null
            };

            _ = FetchAsync();
        }

        public void Remove()
        {
            // when removing entry, make sure it doesn't keep running its download task
            if (task is not null && task.Status is not TaskStatus.RanToCompletion)
            {
                cancelTaskSource?.Cancel();
                Status = EntryStatus.CANCELLED;

                Logger.Log($"Cancelled {url} download due to entry removal");
            }

            var entryvms = SettingsViewModel.Instance.EntryViewModels;
            Utility.Thread.ThreadSafeAction(() => entryvms.Remove(entryvms.First((vm) => vm.entry == this)));
        }

        public void Stop()
        {
            cancelTaskSource.Cancel();
            Status = EntryStatus.CANCELLED;
        }

        public async Task Download()
        {
            ((IEntry)data).Reset();
            cancelTaskSource = new CancellationTokenSource();

            // when a playlist is generated by YouTube, yt-dlp and YouTube Explode fail to get uploader,
            // so we replace it manually
            string outputTemplate = (data switch
            {
                EntryPlaylistData d => Settings.Instance.argTemplateString.Replace("[author]", d.PlaylistAuthor),
                EntryMemberData m => Settings.Instance.argTemplateString.Replace("[author]", m.PlaylistAuthor),
                EntrySingleData s => Settings.Instance.argTemplateString.Replace("[author]", s.Author),
                _ => Settings.Instance.argTemplateString,
            }).Replace(" - Topic", null);

            ProcessStartInfo process = new("./youtube-dl.exe")
            {
                Arguments = (
                    $"\"{url}\" -o {outputTemplate}"
                ),
                RedirectStandardError = true,
                RedirectStandardOutput = true,
                RedirectStandardInput = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            try
            {
                task = Task.Run(async () =>
                {
                    downloadStart = DateTime.Now;
                    Status = EntryStatus.DOWNLOADING;

                    using Process downloadProcess = new()
                    {
                        StartInfo = process,
                        EnableRaisingEvents = true,
                    };

                    Logger logger = new(this);

                    downloadProcess.Exited += (sender, e) => Event.DownloadProcess.Exited(this, sender, e);
                    downloadProcess.ErrorDataReceived += (sender, e) => Event.DownloadProcess.ErrorDataReceived(this, sender, e);
                    downloadProcess.OutputDataReceived += (sender, e) =>
                    {
                        Event.DownloadProcess.OutputDataReceived(this, sender, e);
                        logger.LogToFile(this, e.Data);
                    };

                    downloadProcess.Start();
                    downloadProcess.BeginOutputReadLine();
                    downloadProcess.BeginErrorReadLine();

                    await downloadProcess.WaitForExitAsync(cancelTaskSource.Token);
                });

                await task;
                Status = EntryStatus.DONE;
            }
            catch (TaskCanceledException e)
            {
                Status = EntryStatus.CANCELLED;
            }
            catch (Exception e)
            {
                Status = EntryStatus.ERROR;
            }
        }

        public async Task FetchAsync()
        {
            HttpClient httpClient = new();
            YoutubeClient client = new(httpClient);

            if (videoId is not null)
            {
                if (type is EntryType.SINGLE)
                {
                    await FetchSingleAsync(client);
                }
                else if (type is EntryType.MEMBER && playlistId is not null)
                {
                    await FetchMemberAsync(client);
                }
            }
            else if (playlistId is not null && type is EntryType.PLAYLIST)
            {
                await FetchPlaylistAsync(client);
            }
            else
            {
                Logger.Log($"URL appears to be invalid: {url}");
            }
        }

        async Task FetchSingleAsync(YoutubeClient client)
        {
            Video video = await client.Videos.GetAsync($"https://www.youtube.com/watch?v={videoId}");
            if (data is EntrySingleData singleData)
            {
                singleData.Initialize(video);
            }
        }

        async Task FetchPlaylistAsync(YoutubeClient client)
        {
            try
            {
                var playlist = await client.Playlists.GetAsync($"https://youtube.com/playlist?list={playlistId}");
                var playlistEntries = await client.Playlists.GetVideosAsync($"https://youtube.com/playlist?list={playlistId}");

                if (data is EntryPlaylistData playlistData)
                {
                    playlistData.Initialize(playlist, playlistEntries);
                }
            }
            catch (PlaylistUnavailableException) 
            {
                MessageBox.Show($"Playlist at {url} is unavailable.", "Playlist unavailable", MessageBoxButton.OK);
            }
        }

        async Task FetchMemberAsync(YoutubeClient client)
        {
            await FetchSingleAsync(client);
            await FetchMemberAsync(client);
        }
    }
}
